<!DOCTYPE HTML>
<!--
	Stellar by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Implementation - Material Point Method</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<h1>Implementation</h1>
						<p>Modeling, Simulating, and Rendering</p>
					</header>

				<!-- Main -->
					<div id="main">

						<!-- Content -->
							<section id="content" class="main">
								<!-- <span class="image main"><img src="images/pic04.jpg" alt="" /></span> -->

								<h2>Studying</h2>
								<p>In order to do this project, we have to conquer two main problems, simulation and rendering.</p>
								<p>In the simulation, we start from the following two papers:<ul><li><a href="https://www.math.ucla.edu/~jteran/papers/PGKFTJM17.pdf">Multi-species simulation of porous sand and water mixtures</a></li><li><a href="https://www.math.ucla.edu/~jteran/papers/SSCTS13.pdf">A material point method for snow simulation</a></li></ul></p>
								<p>These two papers are based on the MPM method, adding more restrictions to create better effect. They provide some useful parameters we can reference. Although we produce the different results with the same configuration, these two papers still let us have good understanding how to tune the parameters.</p>

								<h2>Modeling</h2>
								<p></p>

								<h2>Simulating using material point method</h2>
								<p></p>

								<h2>Viewing real-time result with OpenGL</h2>
								<p><span class="image right"><img src="images/OpenGL_screenshot.png" alt=""/></span>For real-time result viewing, we use OpenGL to create a simple scene, and provide several camera views from differnet angles. Then, we bind the vertex buffer to CUDA, so that we can just use the normal OpenGL function to render the MPM particles easily.<br /> We use this scene to check if the simulation is doing well. After we get a satisfying result, we save the particle positions of each frame for OptiXâ„¢ Ray Tracing Engine.</p>

								<h2>Voxelizing and ray tracing</h2>
								<p>From saved particle positions, we load point cloud, voxelize it, and render voxels. GVDB-Voxels library is used for rendering of sparse volumetric data. Integrating with NVIDIA OptiX, it produces high quality ray-tracing result. After all point cloud data are rendered, the saved images of each frame can be combined as video.</p>

								<h2>Generating video</h2>
								<p>We use FFmpeg to combine all the images into one video. For example, we save every frame in PNG format, and use the following command to generate video. We can also specify how many images being displayed in one second (fps).</p>
								<pre><code>ffmpeg -r [fps] -pattern_type glob -i '*.png' -c:v libx264 -vf "format=yuv420p" [video name].mp4</code></pre>

							</section>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<p class="copyright">&copy; Chen Li-Yu, Lin Yi-Sheng, Sung Tzu-Wei. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
					</footer>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
